@using System.Collections
@using System.Reflection
@typeparam T

@if (Item is null)
{
    <em>null</em>
}
else if (Item is string str)
{
    <span>@str</span>
}
else if (Item is IEnumerable enumerable && !(Item is string))
{
    <ul>
        @foreach (var element in enumerable)
        {
            <li>
                <ObjectViewer Item="@element"/>
            </li>
        }
    </ul>
}
else
{
    var type = Item.GetType();

    @if (HasPrettyToString(type))
    {
        <span>@Item</span>
    }
    else
    {
        <table class="table table-sm table-bordered">
            <tbody>
            @foreach (var prop in type.GetProperties(BindingFlags.Public | BindingFlags.Instance))
            {
                <tr>
                    <td><strong>@prop.Name</strong></td>
                    <td>
                        @{
                            var value = prop.GetValue(Item);
                        }
                        <ObjectViewer Item="@value"/>
                    </td>
                </tr>
            }
            </tbody>
        </table>
    }
}

@functions {

    private static bool HasPrettyToString(Type type)
    {
        if (type.IsPrimitive || type.IsEnum || type == typeof(decimal))
            return true;

        // Whitelist types with good ToString()
        if (type == typeof(Guid) || type == typeof(DateTime) || type == typeof(DateTimeOffset) || type == typeof(TimeSpan))
            return true;

        // Many structs have meaningful ToString()
        if (type.IsValueType && type != typeof(ValueType))
            return true;

        // Detect if ToString is overridden
        var toStringMethod = type.GetMethod(nameof(ToString), Type.EmptyTypes);
        return toStringMethod?.DeclaringType != typeof(object);
    }

}

@code {
    [Parameter] public T? Item { get; set; }
}